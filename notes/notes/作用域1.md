# 作用域 - note1（《你不知道的JavaScript》笔记，这个书写的很有趣，可以看看）
## 程序var a = 2 处理时发生了啥
### 了解将要参与到对程序 var a = 2; 进行处理的过程中的演员们。
+  引擎
    - 从头到尾负责整个 JavaScript 程序的编译及执行过程。
+ 编译器 
    - 引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
+ 作用域 
    - 引擎的另一位好朋友，`负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限`。
### 在处理程序var a = 2这些演员具体干了啥
1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量。如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常。
### 了解引擎是如何进行查找的
#### 了解LHS和RHS（你可以理解成 retrieve his source value(取到它的源值)，这意味着“得到某某的 值”）
+ 例子var a = 2，执行了LHS查询，赋值操作通过LHS进行查询。
+ console.log(a), 变量a未进行赋值，则会通过RHS进行查询a的值。
#### 引擎如何在作用域的帮助下正确的查找
```
function foo(a) { console.log( a ); // 2
}
foo( 2 );
```
+ 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。
    - 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗? 作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。 
    - 引擎:哥们太够意思了!好吧，我来执行一下 foo。 引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗? 作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。 
    - 引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。 引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗? 作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。
    - 引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。 引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。 作用域:放心吧，这个变量没有变动过，拿走，不谢。
    - 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。




